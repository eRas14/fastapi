План изучения FastAPI: 10 практических заданий

Задание 1: "Hello, World!" и основы маршрутизации
Цель: Создать базовое приложение FastAPI и понять, как работают эндпоинты.

Задача:
1. Создайте новый файл main.py.
2. Импортируйте FastAPI и создайте экземпляр приложения.
3. Создайте корневой эндпоинт GET /, который возвращает {"message": "Hello, World!"}.
4. Создайте еще один эндпоинт GET /users/{user_id}, который принимает путь user_id (целое число) и возвращает {"user_id": user_id}.
5. Запустите сервер с помощью uvicorn main:app --reload и проверьте оба эндпоинта в браузере.

---

Задание 2: Работа с Query-параметрами
Цель: Научиться обрабатывать параметры, передаваемые в URL.

Задача:
1. Создайте эндпоинт GET /items/.
2. Реализуйте возможность принимать два необязательных query-параметра: skip (целое число, по умолчанию 0) и limit (целое число, по умолчанию 10).
3. Эндпоинт должен возвращать JSON вида {"skip": skip, "limit": limit}.
4. Проверьте его работу, обратившись по адресу /items/?skip=5&limit=20.

---

Задание 3: Создание и валидация данных с Pydantic
Цель: Познакомиться с Pydantic моделями для валидации и сериализации данных.

Задача:
1. Создайте Pydantic-модель Item со следующими полями: name (строка, обязательно), description (строка, необязательно), price (положительное число, обязательно), tax (необязательное число с плавающей точкой).
2. Создайте эндпоинт POST /items/, который принимает тело запроса в виде модели Item.
3. Эндпоинт должен возвращать полученные данные. Реализуйте логику: если tax не передан, установите его в 10.5. Затем верните item и рассчитанную итоговую цену price + tax.

---

Задание 4: Обновление данных (PUT и PATCH)
Цель: Разобраться с разными методами обновления данных.

Задача:
1. Создайте "in-memory" базу данных в виде словаря items = {}.
2. Реализуйте эндпоинт PUT /items/{item_id}, который полностью обновляет объект в словаре items по его item_id. Используйте модель Item из предыдущего задания.
3. Создайте отдельную Pydantic-модель ItemUpdate, где все поля необязательные.
4. Реализуйте эндпоинт PATCH /items/{item_id}, который частично обновляет объект, используя модель ItemUpdate.

---

Задание 5: Обработка ошибок и кастомные исключения
Цель: Научиться возвращать информативные HTTP-ошибки.

Задача:
1. Модифицируйте эндпоинт GET /items/{item_id} из задания 4.
2. Если item_id не найден в словаре items, эндпоинт должен возвращать статус код 404 с сообщением {"detail": "Item not found"}.
3. Создайте кастомное исключение NotEnoughRightsException.
4. Создайте эндпоинт DELETE /items/{item_id}, который "выбрасывает" это исключение, если item_id равен 1 (имитация попытки удалить защищенный элемент). Напишите обработчик исключений, который перехватывает NotEnoughRightsException и возвращает статус 403 с понятным сообщением.

---

Задание 6: Валидация путей и строк с помощью Query и Path
Цель: Углубить знания в валидации входящих параметров.

Задача:
1. Создайте эндпоинт GET /users/.
2. Объявите query-параметр name. Сделайте его обязательным и добавьте валидацию на минимальную (3 символа) и максимальную (50 символов) длину строки.
3. Создайте эндпоинт GET /books/{book_id}.
4. Объявите параметр пути book_id. Добавьте валидацию, что число должно быть не меньше 1 и не больше 1000, используя Path из FastAPI.

---

Задание 7: Внедрение зависимостей (Dependency Injection)
Цель: Понять принцип Dependency Injection для переиспользования кода.

Задача:
1. Создайте зависимость (dependency) common_parameters, которая принимает query-параметры q (строка, необязательный) и limit (целое число). Функция должна возвращать словарь с этими параметрами.
2. Используйте эту зависимость в двух эндпоинтах: GET /depends/one/ и GET /depends/two/. Каждый эндпоинт должен просто возвращать параметры, полученные из зависимости.

---

Задание 8: Работа с базой данных (SQLModel / SQLAlchemy)
Цель: Интегрировать простую базу данных.

Задача:
1. Установите sqlmodel (или sqlalchemy и alembic).
2. Создайте SQLModel-модель User с полями: id (int, primary_key), username (str, unique), email (str).
3. Создайте эндпоинты: